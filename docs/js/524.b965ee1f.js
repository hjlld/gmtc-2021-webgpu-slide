"use strict";(self["webpackChunkgmtc_2021_webgpu_slide"]=self["webpackChunkgmtc_2021_webgpu_slide"]||[]).push([[524],{5404:(e,t,n)=>{n.d(t,{CT:()=>a,Ky:()=>r,ag:()=>i,J9:()=>o,Vc:()=>s,KB:()=>d});const a="let gl = this.canvas.getContext( 'webgl' );\n    gl.createShader( type );\n    gl.shaderSource( shader, sourceCode );\n    gl.compileShader( shader );\n    gl.createProgram();\n    gl.attachShader( program, shader );\n    gl.linkProgram( program );\n    gl.useProgram( program );\n    gl.createBuffer();\n    gl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n    gl.bufferData( gl.ARRAY_BUFFER, dataView, gl.STATIC_DRAW );\n    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n    gl.drawArrays( mode, 0, size );\n",r="let adapter = await navigator.gpu.requestAdapter();\nlet device = await adapter.requestDevice();\nlet context = canvas.getContext('webgpu');\nlet context.configure({ ... });\nlet commandEncoder = device.createCommandEncoder();\n    let renderPassEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    let renderPipeline = await device.createRenderPipelineAsync(pipelineDescriptor);\n    renderPassEncoder.setPipeline(renderPipeline);\n    renderPassEncoder.drawIndexed(indexCount, 1, 0, 0, 0);\n    renderPassEncoder.endPass();\ndevice.queue.submit([ commandEncoder.finish() ]);\n",i="// 获取硬件设备\nlet adapter = await navigator.gpu.requestAdapter();\nlet device = await adapter.requestDevice();\n\n// 可以用 Canvas，也可以不用 Canvas，还可以用很多 Canvas；用的话就把 Canvas 与设备相连\nlet context = canvas.getContext( 'webgpu' );\nlet context.configure( { ... });\n\n// 创建命令编码器，所有 GPU 指令都是通过它发给 GPU 的\nlet commandEncoder = device.createCommandEncoder();\n    \n    // 创建渲染通道、渲染管线、着色器……等等所有你想做的 GPU 指令\n    let renderPassEncoder = commandEncoder.beginRenderPass( renderPassDescriptor );\n    let renderPipeline = await device.createRenderPipelineAsync( renderPipelineDescriptor );\n    renderPassEncoder.setPipeline( renderPipeline );\n    renderPassEncoder.drawIndexed( indexCount, 1, 0, 0, 0 );\n    renderPassEncoder.endPass();\n\n// 结束命令编码器并发送到 GPU 设备的指令队列中\ndevice.queue.submit( [ commandEncoder.finish() ] );\n",o="[[block]]\nstruct Uniforms {\n    [[size(64)]]uPMatrix: mat4x4<f32>;\n    [[size(64)]]uMVMatrix: mat4x4<f32>;\n};\n\n[[group(0), binding(0)]]\nvar<uniform> uniforms: Uniforms;\n\n[[stage(vertex)]]\nfn main (\n    [[location(0)]] aVertexPosition : vec3<f32>\n) -> [[builtin(position)]] vec4<f32> {\n    return uniforms.uPMatrix * uniforms.uMVMatrix * vec4<f32>(aVertexPosition, 1.0);\n}",s="Array.sort( \n        \n    ( a, b ) => {\n\n        return a - b;\n\n    }\n\n);\n\n\n\n\n\n\n",d="let adapter = await navigator.gpu.requestAdapter();\nlet device = await adapter.requestDevice();\nlet commandEncoder = device.createCommandEncoder();\nlet passEncoder = commandEncoder.beginComputePass();\nlet shaderModule = device.createShaderModule({code: shaderCode});\nlet pipeline = await device.createComputePipelineAsync({\n    compute: {\n        module: shaderModule,\n        entryPoint: 'main'\n    }\n});\npassEncoder.setPipeline(pipeline);\npassEncoder.dispatch(threadgroupsPerGrid, 1, 1);\npassEndocer.endPass();\ndevice.queue.submit( [ commandEncoder.finish() ] );\n"},8138:(e,t)=>{t.__esModule=!0,t.shader2=t.shader1=void 0;var n=function(e){return"struct structFixedData {\n    data: array<f32, "+e+">;\n};\n\n[[block]]\nstruct ssbo {\n    data: array<f32>;\n};\n\n[[group(0), binding(0)]]\nvar<storage, write> input: ssbo;\n\nvar<workgroup> sharedData: structFixedData;\n\n[[stage(compute), workgroup_size("+e+",1,1)]]\nfn main(\n    [[builtin(local_invocation_id)]] local_id: vec3<u32>,\n    [[builtin(global_invocation_id)]] global_id: vec3<u32>,\n    [[builtin(workgroup_id)]] group_id: vec3<u32>,\n) {\n    let localIdX: u32 = local_id.x;\n    let globalIdX: u32 = global_id.x;\n\n    sharedData.data[ localIdX ] = input.data[ globalIdX ];\n\n    workgroupBarrier();\n    storageBarrier();\n\n    let offset: u32 = group_id.x * "+e+"u;\n\n    var tmp: f32;\n\n    for ( var k: u32 = 2u; k <= "+e+"u; k = k << 1u ) {\n\n        for ( var j: u32 = k >> 1u; j > 0u; j = j >> 1u ) {\n\n            let ixj: u32 = ( globalIdX ^ j ) - offset;\n\n            if ( ixj > localIdX ) {\n\n                if ( ( globalIdX & k ) == 0u ) {\n\n                    if ( sharedData.data[ localIdX ] > sharedData.data[ ixj ] ) {\n\n                        tmp = sharedData.data[ localIdX ];\n\n                        sharedData.data[ localIdX ] = sharedData.data[ ixj ];\n\n                        sharedData.data[ ixj ] = tmp;\n\n                    }\n\n                } else {\n\n                    if ( sharedData.data[ localIdX ] < sharedData.data[ ixj ] ) {\n\n                        tmp = sharedData.data[ localIdX ];\n                        \n                        sharedData.data[ localIdX ] = sharedData.data[ ixj ];\n\n                        sharedData.data[ ixj ] = tmp;\n\n                    }\n\n                }\n\n            }\n\n            workgroupBarrier();\n            storageBarrier();\n            \n        }\n\n    }\n\n    input.data[ globalIdX ] = sharedData.data[ localIdX ];\n\n}"};t.shader1=n;var a=function(e){return"[[block]]\nstruct ssbo {\n    data: array<f32>;\n};\n\n[[block]]\nstruct struct_Uniform {\n    data: vec4<u32>;\n};\n\n[[group(0), binding(0)]]\nvar<uniform> tonic: struct_Uniform;\n\n[[group(0), binding(1)]]\nvar<storage, write> input: ssbo;\n\n[[stage(compute), workgroup_size("+e+",1,1)]]\nfn main( \n    [[builtin(global_invocation_id)]] global_id: vec3<u32>\n) {\n\n    let globalIdX: u32 = global_id.x;\n\n    var tmp: f32;\n\n    let ixj: u32 = globalIdX ^ tonic.data.y;\n\n    if ( ixj > globalIdX ) {\n\n        if ( ( globalIdX & tonic.data.x ) == 0u ) {\n\n            if ( input.data[ globalIdX ] > input.data[ ixj ] ) {\n\n                tmp = input.data[ globalIdX ];\n\n                input.data[ globalIdX ] = input.data[ ixj ];\n\n                input.data[ ixj ] = tmp;\n\n            }\n\n        } else {\n\n            if ( input.data[ globalIdX ] < input.data[ ixj ] ) {\n\n                tmp = input.data[ globalIdX ];\n\n                input.data[ globalIdX ] = input.data[ ixj ];\n\n                input.data[ ixj ] = tmp;\n\n            }\n\n        }\n\n    }\n\n}"};t.shader2=a},8440:function(e,t,n){n(246),n(71),n(979),n(1118),n(2396),n(9743);var a=this&&this.__awaiter||function(e,t,n,a){function r(e){return e instanceof n?e:new n((function(t){t(e)}))}return new(n||(n=Promise))((function(n,i){function o(e){try{d(a.next(e))}catch(t){i(t)}}function s(e){try{d(a["throw"](e))}catch(t){i(t)}}function d(e){e.done?n(e.value):r(e.value).then(o,s)}d((a=a.apply(e,t||[])).next())}))},r=this&&this.__generator||function(e,t){var n,a,r,i,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"===typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(e){return function(t){return d([e,t])}}function d(i){if(n)throw new TypeError("Generator is already executing.");while(o)try{if(n=1,a&&(r=2&i[0]?a["return"]:i[0]?a["throw"]||((r=a["return"])&&r.call(a),0):a.next)&&!(r=r.call(a,i[1])).done)return r;switch(a=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return o.label++,{value:i[1],done:!1};case 5:o.label++,a=i[1],i=[0];continue;case 7:i=o.ops.pop(),o.trys.pop();continue;default:if(r=o.trys,!(r=r.length>0&&r[r.length-1])&&(6===i[0]||2===i[0])){o=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){o.label=i[1];break}if(6===i[0]&&o.label<r[1]){o.label=r[1],r=i;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(i);break}r[2]&&o.ops.pop(),o.trys.pop();continue}i=t.call(e,o)}catch(s){i=[6,s],a=0}finally{n=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}};t.__esModule=!0,t.WebGPUSort=void 0;var i=n(8138),o=function(){function e(){if(!navigator.gpu)throw new Error("WebGPU not supported!")}return e.prototype.Init=function(){return a(this,void 0,void 0,(function(){var e,t;return r(this,(function(n){switch(n.label){case 0:return e=this,[4,navigator.gpu.requestAdapter({powerPreference:"high-performance"})];case 1:if(e.adapter=n.sent(),!this.adapter)throw new Error("Adapter init failed!");return t=this,[4,this.adapter.requestDevice()];case 2:return t.device=n.sent(),[2]}}))}))},e.prototype.Validate=function(e){for(var t=e.length,n=0;n<t;n++)if(n!==t-1&&e[n]>e[n+1])return console.error("validation error:",n,e[n],e[n+1]),!1;return!0},e.prototype.Run=function(e){return a(this,void 0,void 0,(function(){var t,n,a,o,s,d,l,c,u,p,g,f,h,m,v,b,w,x,P,y,_,C,U,k,G,E,S,q,D,B,I,A;return r(this,(function(r){switch(r.label){case 0:if(!this.device)throw new Error("Device not found!");if(t=this.device.limits.maxComputeWorkgroupSizeX||256,n=this.device.limits.maxComputeWorkgroupsPerDimension||65535,a=this.device.limits.maxStorageBufferBindingSize||134217728,o=e.length,s=e.byteLength,console.log("Buffer size: "+s/1024/1024+" MiB"),s>a)throw new Error("Array is too large!");if(d=Math.max(1,o/t),d>n)throw new Error("Max workgroup dimension size is limited to "+n+"!");return l=Math.log2(o)-Math.log2(2*t+1),c=this.device.createBuffer({label:"input",mappedAtCreation:!0,size:s,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),u=c.getMappedRange(),new Float32Array(u).set(e),c.unmap(),p=this.device.createShaderModule({label:"shader1",code:i.shader1(t)}),g=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),f=this.device.createPipelineLayout({bindGroupLayouts:[g]}),[4,this.device.createComputePipelineAsync({label:"pipeline1",compute:{module:p,entryPoint:"main"},layout:f})];case 1:for(h=r.sent(),m=this.device.createBindGroup({layout:g,entries:[{binding:0,resource:{buffer:c}}]}),v=0;v<l;v++)b=this.device.createCommandEncoder(),w=b.beginComputePass(),w.setPipeline(h),w.setBindGroup(0,m),w.dispatch(d,1,1),w.endPass(),this.device.queue.submit([b.finish()]);return x=new Uint32Array([0,0,0,0]),P=this.device.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),y=this.device.createShaderModule({label:"shader2",code:i.shader2(t)}),_=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),C=this.device.createPipelineLayout({bindGroupLayouts:[_]}),[4,this.device.createComputePipelineAsync({label:"pipeline2",compute:{module:y,entryPoint:"main"},layout:C})];case 2:if(U=r.sent(),k=this.device.createBindGroup({layout:_,entries:[{binding:0,resource:{buffer:P}},{binding:1,resource:{buffer:c}}]}),d>1)for(G=d>>l;G<=o;G<<=1)for(E=G>>1;E>0;E>>=1)S=this.device.createCommandEncoder(),q=S.beginComputePass(),q.setPipeline(U),q.setBindGroup(0,k),x[0]=G,x[1]=E,this.device.queue.writeBuffer(P,0,x),q.dispatch(d,1,1),q.endPass(),this.device.queue.submit([S.finish()]);return D=this.device.createCommandEncoder(),B=this.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),D.copyBufferToBuffer(c,0,B,0,s),this.device.queue.submit([D.finish()]),console.time("GPU sort - result buffer map async"),[4,B.mapAsync(GPUMapMode.READ)];case 3:return r.sent(),console.timeEnd("GPU sort - result buffer map async"),I=B.getMappedRange(),A=new Float32Array(I),[2,A]}}))}))},e.prototype.Dispose=function(){var e;null===(e=this.device)||void 0===e||e.destroy()},e}();t.WebGPUSort=o},3832:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(1959),r=n(3673);function i(e){const t=(0,a.iH)(0),n=n=>{if(" "===n.key||"Spacebar"===n.key){if(t.value===e)return void(t.value=0);t.value++}};return(0,r.bv)((()=>{window.addEventListener("keyup",n)})),(0,r.Jd)((()=>{window.removeEventListener("keyup",n)})),{show:t}}},1851:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(3673),r=n(2323);function i(e,t,n,i,o,s){const d=(0,a.up)("prism");return(0,a.wg)(),(0,a.j4)(d,{language:n.language,class:(0,r.C_)(n.fontClass)},{default:(0,a.w5)((()=>[(0,a.Uk)((0,r.zw)(n.code),1)])),_:1},8,["language","class"])}n(3857);var o=n(4761),s=n.n(o);n(4732),n(8763);const d={components:{prism:s()},props:{code:{type:String,required:!0},language:{type:String,default:"javascript"},fontClass:{type:String,default:"display-1"}}};d.render=i,d.__scopeId="data-v-30dcf0fe";const l=d},5524:(e,t,n)=>{n.r(t),n.d(t,{default:()=>X});var a=n(3673),r=n(2323);const i={key:0,class:"row justify-center items-center content-center wrap q-gutter-md text-white text-left text-h4 text-weight-regular"},o=(0,a._)("div",{class:"col-10 text-center text-h3 text-weight-bold"},[(0,a.Uk)(" GPU 通用计算 - "),(0,a._)("del",null,"WebGL 2.0"),(0,a.Uk)(" WebGPU Compute Shader ")],-1),s=(0,a._)("div",{class:"col-10 q-pa-md p-box"},[(0,a._)("ul",null,[(0,a._)("li",{class:"q-py-md"},"Intel 公司曾提交了 WebGL 2.0 Compute 标准，该标准来自 OpenGL ES 3.1 Compute "),(0,a._)("li",{class:"q-py-md"},"但只有 Chrome 浏览器实现了这一标准，Chrome 团队在实现 WebGL 2.0 Compute 时遇到了巨大的阻力"),(0,a._)("li",{class:"q-py-md"},"本质是因为 WebGL 并不与现代 GPU 的设计理念匹配，导致了很多 CPU 和 GPU 性能问题"),(0,a._)("li",{class:"q-py-md"},"Intel 公司决定停止继续开发 WebGL 2.0 Compute，而将注意力转移到 WebGPU 上"),(0,a._)("li",{class:"q-py-md"},"Google 已经将 WebGL 2.0 Compute 支持从 Chrome 中移除，该标准已经名存实亡")])],-1),d=[o,s],l={key:1,class:"row justify-center items-center content-center wrap q-gutter-md text-white text-left text-h4 text-weight-regular"},c=(0,a._)("div",{class:"col-10 text-center text-h3 text-weight-bold"}," 双调排序 - 這是一种可以并行计算的排序方法 ",-1),u={class:"col-4 text-h5 text-weight-bold p-box q-px-md"},p={class:"col-7 text-h5 text-weight-bold p-box q-px-md"},g={key:2,class:"p-box row justify-center items-center content-center wrap q-gutter-md text-white text-left text-h4 text-weight-regular",style:{width:"90%"}},f={class:"col-3 text-center text-h5 text-weight-bold"},h=(0,a._)("div",{class:"q-mb-md"},"CPU 排序",-1),m=(0,a.Uk)("开始排序"),v={key:0,class:"q-mb-md text-h3"},b={class:"col text-center text-h5 text-weight-bold"},w=(0,a._)("div",{class:"q-mb-md"},[(0,a._)("kbd",null,"Array.length = Math.pow( 2, 23 ); //8,388,608")],-1),x=(0,a.Uk)("初始化数组"),P={class:"col-3 text-center text-h5 text-weight-bold"},y=(0,a._)("div",{class:"q-mb-md"},"GPU 排序",-1),_=(0,a.Uk)("开始排序"),C={key:0,class:"q-mb-md text-h3"};function U(e,t,n,o,s,U){const k=(0,a.up)("highlight-code"),G=(0,a.up)("q-btn"),E=(0,a.up)("q-scroll-area"),S=(0,a.up)("q-page");return(0,a.wg)(),(0,a.j4)(S,{class:"flex flex-center"},{default:(0,a.w5)((()=>[0===e.show?((0,a.wg)(),(0,a.iD)("div",i,d)):1===e.show?((0,a.wg)(),(0,a.iD)("div",l,[c,(0,a._)("div",u,[(0,a.Wm)(k,{code:e.cpuSortCode},null,8,["code"])]),(0,a._)("div",p,[(0,a.Wm)(k,{code:e.gpuSortCode},null,8,["code"])])])):2===e.show?((0,a.wg)(),(0,a.iD)("div",g,[(0,a._)("div",f,[h,(0,a._)("div",null,[(0,a.Wm)(G,{color:"secondary",class:"q-mb-md",size:"xl",onClick:t[0]||(t[0]=t=>e.CPUSort())},{default:(0,a.w5)((()=>[m])),_:1})]),0!==e.cpuTime?((0,a.wg)(),(0,a.iD)("div",v,(0,r.zw)(`${Math.round(e.cpuTime)} ms`),1)):(0,a.kq)("",!0)]),(0,a._)("div",b,[w,(0,a._)("div",null,[(0,a.Wm)(G,{color:"secondary",size:"xl",onClick:t[1]||(t[1]=t=>e.randomizeArray())},{default:(0,a.w5)((()=>[x])),_:1})])]),(0,a._)("div",P,[y,(0,a._)("div",null,[(0,a.Wm)(G,{color:"secondary",size:"xl",class:"q-mb-md",onClick:t[2]||(t[2]=t=>e.GPUSort())},{default:(0,a.w5)((()=>[_])),_:1})]),0!==e.gpuTime?((0,a.wg)(),(0,a.iD)("div",C,(0,r.zw)(`${Math.round(e.gpuTime)} ms`),1)):(0,a.kq)("",!0)]),(0,a.Wm)(E,{class:"col-11 text-left text-caption text-weight-lighter q-pa-xl",style:{height:"500px"}},{default:(0,a.w5)((()=>[(0,a.Uk)((0,r.zw)(e.textArray),1)])),_:1})])):(0,a.kq)("",!0)])),_:1})}n(979),n(1118),n(2396),n(7098);var k=n(1959),G=n(3832),E=n(1851),S=n(5404),q=n(8440);const D=(0,a.aZ)({components:{HighlightCode:E.Z},setup(){const{show:e}=(0,G.Z)(2),t=new Float32Array({length:Math.pow(2,23)}),n=(0,k.iH)(""),a=(0,k.iH)(0),r=(0,k.iH)(0),i=e=>{let t=275,a=e.slice(0,t);n.value="";for(let r=0;r<a.length;++r)n.value+=`${a[r].toString()}, `},o=async()=>{const e=new q.WebGPUSort;await e.Init();const n=performance.now(),a=await e.Run(t);if(i(a),r.value=performance.now()-n,!e.Validate(a))throw new Error("GPU sort validation NOT passed!");console.log("GPU sort validation passed!")},s=()=>{a.value=0,r.value=0;for(let e=0;e<t.length;++e)t[e]=Math.random();i(t)},d=()=>{a.value=0;let e=t.slice(0),n=performance.now();e.sort(((e,t)=>e-t)),a.value=performance.now()-n,i(e)};return{cpuSortCode:S.Vc,gpuSortCode:S.KB,show:e,array:t,textArray:n,cpuTime:a,gpuTime:r,GPUSort:o,CPUSort:d,arrayToText:i,randomizeArray:s}}});var B=n(4379),I=n(8240),A=n(7704),M=n(7518),j=n.n(M);D.render=U;const X=D;j()(D,"components",{QPage:B.Z,QBtn:I.Z,QScrollArea:A.Z})}}]);