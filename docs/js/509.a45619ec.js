"use strict";(self["webpackChunkgmtc_2021_webgpu_slide"]=self["webpackChunkgmtc_2021_webgpu_slide"]||[]).push([[509],{5404:(e,n,t)=>{t.d(n,{CT:()=>r,Ky:()=>a,ag:()=>s,J9:()=>d,Vc:()=>i,KB:()=>c});const r="let gl = this.canvas.getContext( 'webgl' );\n    gl.createShader( type );\n    gl.shaderSource( shader, sourceCode );\n    gl.compileShader( shader );\n    gl.createProgram();\n    gl.attachShader( program, shader );\n    gl.linkProgram( program );\n    gl.useProgram( program );\n    gl.createBuffer();\n    gl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n    gl.bufferData( gl.ARRAY_BUFFER, dataView, gl.STATIC_DRAW );\n    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );\n    gl.drawArrays( mode, 0, size );\n",a="let adapter = await navigator.gpu.requestAdapter();\nlet device = await adapter.requestDevice();\nlet context = canvas.getContext('webgpu');\nlet context.configure({ ... });\nlet commandEncoder = device.createCommandEncoder();\n    let renderPassEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    let renderPipeline = await device.createRenderPipelineAsync(pipelineDescriptor);\n    renderPassEncoder.setPipeline(renderPipeline);\n    renderPassEncoder.drawIndexed(indexCount, 1, 0, 0, 0);\n    renderPassEncoder.endPass();\ndevice.queue.submit([ commandEncoder.finish() ]);\n",s="// 获取硬件设备\nlet adapter = await navigator.gpu.requestAdapter();\nlet device = await adapter.requestDevice();\n\n// 可以用 Canvas，也可以不用 Canvas，还可以用很多 Canvas；用的话就把 Canvas 与设备相连\nlet context = canvas.getContext( 'webgpu' );\nlet context.configure( { ... });\n\n// 创建命令编码器，所有 GPU 指令都是通过它发给 GPU 的\nlet commandEncoder = device.createCommandEncoder();\n    \n    // 创建渲染通道、渲染管线、着色器……等等所有你想做的 GPU 指令\n    let renderPassEncoder = commandEncoder.beginRenderPass( renderPassDescriptor );\n    let renderPipeline = await device.createRenderPipelineAsync( renderPipelineDescriptor );\n    renderPassEncoder.setPipeline( renderPipeline );\n    renderPassEncoder.drawIndexed( indexCount, 1, 0, 0, 0 );\n    renderPassEncoder.endPass();\n\n// 结束命令编码器并发送到 GPU 设备的指令队列中\ndevice.queue.submit( [ commandEncoder.finish() ] );\n",d="[[block]]\nstruct Uniforms {\n    [[size(64)]]uPMatrix: mat4x4<f32>;\n    [[size(64)]]uMVMatrix: mat4x4<f32>;\n};\n\n[[group(0), binding(0)]]\nvar<uniform> uniforms: Uniforms;\n\n[[stage(vertex)]]\nfn main (\n    [[location(0)]] aVertexPosition : vec3<f32>\n) -> [[builtin(position)]] vec4<f32> {\n    return uniforms.uPMatrix * uniforms.uMVMatrix * vec4<f32>(aVertexPosition, 1.0);\n}",i="Array.sort( \n        \n    ( a, b ) => {\n\n        return a - b;\n\n    }\n\n);\n\n\n\n\n\n\n",c="let adapter = await navigator.gpu.requestAdapter();\nlet device = await adapter.requestDevice();\nlet commandEncoder = device.createCommandEncoder();\nlet passEncoder = commandEncoder.beginComputePass();\nlet shaderModule = device.createShaderModule({code: shaderCode});\nlet pipeline = await device.createComputePipelineAsync({\n    compute: {\n        module: shaderModule,\n        entryPoint: 'main'\n    }\n});\npassEncoder.setPipeline(pipeline);\npassEncoder.dispatch(threadgroupsPerGrid, 1, 1);\npassEndocer.endPass();\ndevice.queue.submit( [ commandEncoder.finish() ] );\n"},3832:(e,n,t)=>{t.d(n,{Z:()=>s});var r=t(1959),a=t(3673);function s(e){const n=(0,r.iH)(0),t=t=>{if(" "===t.key||"Spacebar"===t.key){if(n.value===e)return void(n.value=0);n.value++}};return(0,a.bv)((()=>{window.addEventListener("keyup",t)})),(0,a.Jd)((()=>{window.removeEventListener("keyup",t)})),{show:n}}},1851:(e,n,t)=>{t.d(n,{Z:()=>o});var r=t(3673),a=t(2323);function s(e,n,t,s,d,i){const c=(0,r.up)("prism");return(0,r.wg)(),(0,r.j4)(c,{language:t.language,class:(0,a.C_)(t.fontClass)},{default:(0,r.w5)((()=>[(0,r.Uk)((0,a.zw)(t.code),1)])),_:1},8,["language","class"])}t(3857);var d=t(4761),i=t.n(d);t(4732),t(8763);const c={components:{prism:i()},props:{code:{type:String,required:!0},language:{type:String,default:"javascript"},fontClass:{type:String,default:"display-1"}}};c.render=s,c.__scopeId="data-v-30dcf0fe";const o=c},7509:(e,n,t)=>{t.r(n),t.d(n,{default:()=>x});var r=t(3673);const a={key:0,class:"row justify-center items-center content-center wrap q-gutter-md text-white text-left text-h4 text-weight-regular"},s=(0,r._)("div",{class:"col-10 text-center text-h3 text-weight-bold"}," WebGPU 开发体验 ",-1),d=(0,r._)("div",{class:"col-10 q-pa-md p-box"},[(0,r._)("ul",null,[(0,r._)("li",{class:"q-py-md"},"大量的异步方法，需要 Promise 知识和能力"),(0,r._)("li",{class:"q-py-md"},[(0,r.Uk)("良好的 TypeScript 支持，"),(0,r._)("kbd",null,"npm i @webgpu/types -D")]),(0,r._)("li",{class:"q-py-md"},"全新的 WGSL 语言，语法怪异，类似 Rust、TypeScript 的缝合怪"),(0,r._)("li",{class:"q-py-md"},[(0,r.Uk)("回滚 GLSL 4.5 也可以，"),(0,r._)("kbd",null,"npm i @webgpu/glslang"),(0,r.Uk)("，预编译为 SPIR-V 的二进制着色器代码")]),(0,r._)("li",{class:"q-py-md"},"可以尽情使用全新的 ES 特性和浏览器功能")])],-1),i=[s,d],c={key:1,class:"row justify-center items-center content-center wrap q-gutter-md text-white text-left text-h4 text-weight-regular"},o={class:"col-12 q-px-md p-box"},l={key:2,class:"row justify-center items-center content-center wrap q-gutter-md text-white text-left text-h4 text-weight-regular"};function u(e,n,t,s,d,u){const p=(0,r.up)("highlight-code"),g=(0,r.up)("q-scroll-area"),m=(0,r.up)("q-page");return(0,r.wg)(),(0,r.j4)(m,{class:"flex flex-center"},{default:(0,r.w5)((()=>[0===e.show?((0,r.wg)(),(0,r.iD)("div",a,i)):1===e.show?((0,r.wg)(),(0,r.iD)("div",c,[(0,r._)("div",o,[(0,r.Wm)(p,{code:e.wgslCode,language:"rust"},null,8,["code"])])])):2===e.show?((0,r.wg)(),(0,r.iD)("div",l,[(0,r.Wm)(g,{class:"col-12 q-px-md p-box",style:{width:"90vw",height:"90vh"}},{default:(0,r.w5)((()=>[(0,r.Wm)(p,{code:e.howToDrawCode},null,8,["code"])])),_:1})])):(0,r.kq)("",!0)])),_:1})}var p=t(1851),g=t(5404),m=t(3832);const w=(0,r.aZ)({components:{HighlightCode:p.Z},setup(){const{show:e}=(0,m.Z)(2);return{howToDrawCode:g.ag,wgslCode:g.J9,show:e}}});var v=t(4379),f=t(7704),h=t(7518),P=t.n(h);w.render=u;const x=w;P()(w,"components",{QPage:v.Z,QScrollArea:f.Z})}}]);