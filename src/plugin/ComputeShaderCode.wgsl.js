"use strict";
exports.__esModule = true;
exports.shader2 = exports.shader1 = void 0;
var shader1 = function (MAX_THREAD_NUM) {
    return "struct structFixedData {\n    data: array<f32, " + MAX_THREAD_NUM + ">;\n};\n\n[[block]]\nstruct ssbo {\n    data: array<f32>;\n};\n\n[[group(0), binding(0)]]\nvar<storage, write> input: ssbo;\n\nvar<workgroup> sharedData: structFixedData;\n\n[[stage(compute), workgroup_size(" + MAX_THREAD_NUM + ",1,1)]]\nfn main(\n    [[builtin(local_invocation_id)]] local_id: vec3<u32>,\n    [[builtin(global_invocation_id)]] global_id: vec3<u32>,\n    [[builtin(workgroup_id)]] group_id: vec3<u32>,\n) {\n    let localIdX: u32 = local_id.x;\n    let globalIdX: u32 = global_id.x;\n\n    sharedData.data[ localIdX ] = input.data[ globalIdX ];\n\n    workgroupBarrier();\n    storageBarrier();\n\n    let offset: u32 = group_id.x * " + MAX_THREAD_NUM + "u;\n\n    var tmp: f32;\n\n    for ( var k: u32 = 2u; k <= " + MAX_THREAD_NUM + "u; k = k << 1u ) {\n\n        for ( var j: u32 = k >> 1u; j > 0u; j = j >> 1u ) {\n\n            let ixj: u32 = ( globalIdX ^ j ) - offset;\n\n            if ( ixj > localIdX ) {\n\n                if ( ( globalIdX & k ) == 0u ) {\n\n                    if ( sharedData.data[ localIdX ] > sharedData.data[ ixj ] ) {\n\n                        tmp = sharedData.data[ localIdX ];\n\n                        sharedData.data[ localIdX ] = sharedData.data[ ixj ];\n\n                        sharedData.data[ ixj ] = tmp;\n\n                    }\n\n                } else {\n\n                    if ( sharedData.data[ localIdX ] < sharedData.data[ ixj ] ) {\n\n                        tmp = sharedData.data[ localIdX ];\n                        \n                        sharedData.data[ localIdX ] = sharedData.data[ ixj ];\n\n                        sharedData.data[ ixj ] = tmp;\n\n                    }\n\n                }\n\n            }\n\n            workgroupBarrier();\n            storageBarrier();\n            \n        }\n\n    }\n\n    input.data[ globalIdX ] = sharedData.data[ localIdX ];\n\n}";
};
exports.shader1 = shader1;
var shader2 = function (MAX_THREAD_NUM) {
    return "[[block]]\nstruct ssbo {\n    data: array<f32>;\n};\n\n[[block]]\nstruct struct_Uniform {\n    data: vec4<u32>;\n};\n\n[[group(0), binding(0)]]\nvar<uniform> tonic: struct_Uniform;\n\n[[group(0), binding(1)]]\nvar<storage, write> input: ssbo;\n\n[[stage(compute), workgroup_size(" + MAX_THREAD_NUM + ",1,1)]]\nfn main( \n    [[builtin(global_invocation_id)]] global_id: vec3<u32>\n) {\n\n    let globalIdX: u32 = global_id.x;\n\n    var tmp: f32;\n\n    let ixj: u32 = globalIdX ^ tonic.data.y;\n\n    if ( ixj > globalIdX ) {\n\n        if ( ( globalIdX & tonic.data.x ) == 0u ) {\n\n            if ( input.data[ globalIdX ] > input.data[ ixj ] ) {\n\n                tmp = input.data[ globalIdX ];\n\n                input.data[ globalIdX ] = input.data[ ixj ];\n\n                input.data[ ixj ] = tmp;\n\n            }\n\n        } else {\n\n            if ( input.data[ globalIdX ] < input.data[ ixj ] ) {\n\n                tmp = input.data[ globalIdX ];\n\n                input.data[ globalIdX ] = input.data[ ixj ];\n\n                input.data[ ixj ] = tmp;\n\n            }\n\n        }\n\n    }\n\n}";
};
exports.shader2 = shader2;
